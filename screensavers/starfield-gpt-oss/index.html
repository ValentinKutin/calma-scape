<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Starry Night & Spiral Galaxies</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block; /* no scrollbar */
      }
    </style>
  </head>
  <body>
    <canvas id="space"></canvas>

    <script>
      (() => {
        const canvas = document.getElementById("space");
        const ctx = canvas.getContext("2d", { alpha: true });
        let cw, ch;
        const resize = () => {
          cw = canvas.width = window.innerWidth;
          ch = canvas.height = window.innerHeight;
        };
        window.addEventListener("resize", resize);
        resize(); // initial

        /* ---------- Helpers ---------- */
        const rnd = (min, max) => Math.random() * (max - min) + min;
        const degToRad = (d) => (d * Math.PI) / 180;

        /* ---------- Stars ---------- */
        class Star {
          constructor(x, y, radius, baseAlpha) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.baseAlpha = baseAlpha;
            this.twinkle = rnd(0.005, 0.02); // speed of twinkle
            this.phase = rnd(0, Math.PI * 2);
          }
          draw(dt) {
            this.phase += this.twinkle * dt;
            const alpha = this.baseAlpha + 0.3 * Math.sin(this.phase);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }

        /* ---------- Galaxy ---------- */
        class Galaxy {
          constructor(x, y, size, numStars, rotSpeed, direction) {
            this.cx = x;
            this.cy = y;
            this.size = size; // max radius
            this.numStars = numStars;
            this.rotSpeed = rotSpeed; // rad/s
            this.direction = direction; // +1 or -1
            this.angle = rnd(0, Math.PI * 2);
            this.stars = []; // stars in polar coords
            this.generateStars();
            this.coreGlow = this.createCoreGlow();
          }
          createCoreGlow() {
            const gradient = ctx.createRadialGradient(
              this.cx,
              this.cy,
              0,
              this.cx,
              this.cy,
              this.size * 0.3
            );
            gradient.addColorStop(0, "rgba(255,255,255,0.6)");
            gradient.addColorStop(1, "rgba(255,255,255,0)");
            return gradient;
          }
          generateStars() {
            // Spiral formula: r = a * exp(b * theta)
            const a = this.size / 5; // controls tightness
            const b = 0.15; // controls pitch
            const maxTheta = 8 * Math.PI; // how many turns
            for (let i = 0; i < this.numStars; i++) {
              const theta = rnd(0, maxTheta);
              const r = a * Math.exp(b * theta);
              const phi = rnd(-Math.PI / 16, Math.PI / 16); // spread arm
              this.stars.push({
                r: r,
                theta: theta + phi,
                radius: rnd(0.5, 1.8),
                alpha: rnd(0.6, 1),
              });
            }
          }
          update(dt) {
            this.angle += this.rotSpeed * dt * this.direction;
          }
          draw() {
            // Core
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = this.coreGlow;
            ctx.beginPath();
            ctx.arc(this.cx, this.cy, this.size * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Arms
            ctx.save();
            ctx.globalCompositeOperation = "lighter";
            ctx.translate(this.cx, this.cy);
            ctx.rotate(this.angle);
            this.stars.forEach((st) => {
              const x = st.r * Math.cos(st.theta);
              const y = st.r * Math.sin(st.theta);
              ctx.globalAlpha = st.alpha;
              ctx.fillStyle = "#fff";
              ctx.beginPath();
              ctx.arc(x, y, st.radius, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.restore();
          }
        }

        /* ---------- Meteor ---------- */
        class Meteor {
          constructor() {
            const side = rnd(0, 4); // 0: top,1:right,2:bottom,3:left
            const speed = rnd(200, 400); // pixels per second
            const angle = rnd(20, 70); // angle of fall
            const len = rnd(50, 120);
            const alpha = rnd(0.8, 1);
            if (side === 0) {
              // top
              this.x = rnd(0, cw);
              this.y = -len;
              this.vx = Math.cos(degToRad(angle)) * speed;
              this.vy = Math.sin(degToRad(angle)) * speed;
            } else if (side === 1) {
              // right
              this.x = cw + len;
              this.y = rnd(0, ch);
              this.vx = -Math.cos(degToRad(angle)) * speed;
              this.vy = Math.sin(degToRad(angle)) * speed;
            } else if (side === 2) {
              // bottom
              this.x = rnd(0, cw);
              this.y = ch + len;
              this.vx = Math.cos(degToRad(angle)) * speed;
              this.vy = -Math.sin(degToRad(angle)) * speed;
            } else {
              // left
              this.x = -len;
              this.y = rnd(0, ch);
              this.vx = Math.cos(degToRad(angle)) * speed;
              this.vy = -Math.sin(degToRad(angle)) * speed;
            }
            this.len = len;
            this.alpha = alpha;
          }
          update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
          }
          draw() {
            const endX =
              this.x - (this.vx / Math.hypot(this.vx, this.vy)) * this.len;
            const endY =
              this.y - (this.vy / Math.hypot(this.vx, this.vy)) * this.len;
            const grad = ctx.createLinearGradient(this.x, this.y, endX, endY);
            grad.addColorStop(0, `rgba(255,255,255,${this.alpha})`);
            grad.addColorStop(1, "rgba(255,255,255,0)");
            ctx.strokeStyle = grad;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          }
          isOffScreen() {
            return (
              this.x < -200 ||
              this.x > cw + 200 ||
              this.y < -200 ||
              this.y > ch + 200
            );
          }
        }

        /* ---------- Scene Setup ---------- */
        const stars = [];
        const numStars = 500;
        for (let i = 0; i < numStars; i++) {
          const x = rnd(0, cw);
          const y = rnd(0, ch);
          const radius = rnd(0.5, 1.5);
          const baseAlpha = rnd(0.2, 0.8);
          stars.push(new Star(x, y, radius, baseAlpha));
        }

        const galaxies = [];
        const galaxyConfigs = [
          {
            x: cw * 0.3,
            y: ch * 0.4,
            size: 120,
            stars: 200,
            rot: 0.02,
            dir: 1,
          },
          {
            x: cw * 0.7,
            y: ch * 0.6,
            size: 160,
            stars: 300,
            rot: 0.015,
            dir: -1,
          },
          {
            x: cw * 0.5,
            y: ch * 0.8,
            size: 140,
            stars: 250,
            rot: 0.025,
            dir: 1,
          },
        ];
        galaxyConfigs.forEach((cfg) => {
          galaxies.push(
            new Galaxy(cfg.x, cfg.y, cfg.size, cfg.stars, cfg.rot, cfg.dir)
          );
        });

        const meteors = [];
        let meteorTimer = 0;
        const METEOR_INTERVAL = 5; // seconds

        /* ---------- Animation Loop ---------- */
        let lastTime = performance.now();
        const animate = () => {
          const now = performance.now();
          const dt = (now - lastTime) / 1000; // seconds
          lastTime = now;
          meteorTimer += dt;

          // Clear with a dark gradient for depth
          const gradient = ctx.createLinearGradient(0, 0, 0, ch);
          gradient.addColorStop(0, "#000010");
          gradient.addColorStop(1, "#000000");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, cw, ch);

          // Draw background stars
          stars.forEach((st) => st.draw(dt));

          // Update & draw galaxies
          galaxies.forEach((g) => {
            g.update(dt);
            g.draw();
          });

          // Update & draw meteors
          meteors.forEach((m) => {
            m.update(dt);
            m.draw();
          });
          // Remove off-screen meteors
          for (let i = meteors.length - 1; i >= 0; i--) {
            if (meteors[i].isOffScreen()) meteors.splice(i, 1);
          }

          // Spawn new meteor occasionally
          if (meteorTimer >= METEOR_INTERVAL) {
            meteors.push(new Meteor());
            meteorTimer = 0;
          }

          requestAnimationFrame(animate);
        };
        requestAnimationFrame(animate);
      })();
    </script>
  </body>
</html>
